(() => {
    const container = document.getElementById('globe-container');
    const tooltip = document.getElementById('tooltip');
    const button = document.getElementById('spinButton');

    let scene, camera, renderer, earthGroup, earthMesh, cloudMesh, atmosphereMesh;
    let markers = [], glowSprite, selectedMarker;
    let isSpinning = false, spinStartTime = 0;
    const SPIN_DURATION = 3000; // ms
    const TOTAL_SPINS = 3;

    const destinations = [
        { name: 'Paris, France', lat: 48.8566, lon: 2.3522 },
        { name: 'Tokyo, Japan', lat: 35.6895, lon: 139.6917 },
        { name: 'New York, USA', lat: 40.7128, lon: -74.0060 },
        { name: 'Sydney, Australia', lat: -33.8688, lon: 151.2093 },
        { name: 'Cape Town, South Africa', lat: -33.9249, lon: 18.4241 }
    ];

    init();
    animate();

    function createPixelEarthTexture() {
        const width = 64;
        const height = 32;
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');

        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                let colorType;
                if (y < 4 || y > height - 5) { 
                    colorType = 2; // ice caps
                } else if ((x + y) % 7 === 0 || (x * y) % 11 === 0) {
                    colorType = 1; // land
                } else {
                    colorType = 0; // water
                }

                const lightFactor = 0.6 + 0.4 * (x / width);
                let color;
                if (colorType === 0) color = `rgb(${0 * lightFactor}, ${70 * lightFactor}, ${170 * lightFactor})`;
                if (colorType === 1) color = `rgb(${30 * lightFactor}, ${120 * lightFactor}, ${50 * lightFactor})`;
                if (colorType === 2) color = `rgb(${200 * lightFactor}, ${200 * lightFactor}, ${200 * lightFactor})`;

                ctx.fillStyle = color;
                ctx.fillRect(x, y, 1, 1);
            }
        }

        return new THREE.CanvasTexture(canvas);
    }

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.z = 3;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const directional = new THREE.DirectionalLight(0xffffff, 1);
        directional.position.set(5, 3, 5);
        scene.add(directional);

        earthGroup = new THREE.Group();
        scene.add(earthGroup);

        const earthGeo = new THREE.SphereGeometry(1, 64, 64);
        const earthMat = new THREE.MeshPhongMaterial({ map: createPixelEarthTexture() });
        earthMesh = new THREE.Mesh(earthGeo, earthMat);
        earthGroup.add(earthMesh);

        destinations.forEach(dest => {
            const geo = new THREE.SphereGeometry(0.025, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0x888888 });
            const marker = new THREE.Mesh(geo, mat);
            const pos = latLonToXYZ(dest.lat, dest.lon, 1.02);
            marker.position.set(pos.x, pos.y, pos.z);
            marker.userData = { destination: dest };
            markers.push(marker);
            earthGroup.add(marker);
        });

        const spriteMat = new THREE.SpriteMaterial({ color: 0xff4444, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
        glowSprite = new THREE.Sprite(spriteMat);
        glowSprite.scale.set(0.15, 0.15, 0.15);
        glowSprite.visible = false;
        scene.add(glowSprite);

        button.addEventListener('click', startSpin);

        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
    }

    function latLonToXYZ(lat, lon, radius) {
        const phi = THREE.MathUtils.degToRad(90 - lat);
        const theta = THREE.MathUtils.degToRad(lon);
        return {
            x: radius * Math.sin(phi) * Math.sin(theta),
            y: radius * Math.cos(phi),
            z: radius * Math.sin(phi) * Math.cos(theta)
        };
    }

    function startSpin() {
        if (isSpinning) return;
        tooltip.style.display = "none";
        glowSprite.visible = false;
        selectedMarker = markers[Math.floor(Math.random() * markers.length)];
        button.disabled = true;
        button.textContent = "Spinning...";
        isSpinning = true;
        spinStartTime = Date.now();
    }

    function animate() {
        requestAnimationFrame(animate);

        if (isSpinning) {
            const elapsed = Date.now() - spinStartTime;
            const progress = Math.min(elapsed / SPIN_DURATION, 1);
            const eased = easeInOutQuart(progress);

            const destLon = selectedMarker.userData.destination.lon;
            const destLat = selectedMarker.userData.destination.lat;

            const targetRotY = THREE.MathUtils.degToRad(-destLon);
            const targetRotX = THREE.MathUtils.degToRad(destLat * 0.5);

            const totalRotY = TOTAL_SPINS * Math.PI * 2 + targetRotY;
            const totalRotX = targetRotX;

            earthGroup.rotation.y = totalRotY * eased;
            earthGroup.rotation.x = totalRotX * eased;

            if (progress >= 1) {
                isSpinning = false;
                button.disabled = false;
                button.textContent = "Pick My Travel Destination";
                showTooltip();
            }
        }

        markers.forEach(m => {
            m.material.color.set((m === selectedMarker && !isSpinning) ? 0xff4444 : 0x888888);
        });

        if (selectedMarker && !isSpinning) {
            const worldPos = selectedMarker.position.clone().applyMatrix4(earthGroup.matrixWorld).multiplyScalar(1.08);
            glowSprite.position.copy(worldPos);
            const pulse = 0.15 + 0.05 * Math.sin(Date.now() * 0.005);
            glowSprite.scale.set(pulse, pulse, pulse);
            glowSprite.visible = true;
            updateTooltipPosition();
        }

        renderer.render(scene, camera);
    }

    function showTooltip() {
        tooltip.textContent = "Your next budget trip: " + selectedMarker.userData.destination.name;
        tooltip.style.display = "block";
        updateTooltipPosition();
    }

    function updateTooltipPosition() {
        if (!selectedMarker || tooltip.style.display === "none") return;
        const vector = selectedMarker.position.clone().applyMatrix4(earthGroup.matrixWorld);
        vector.project(camera);
        const x = (vector.x * 0.5 + 0.5) * container.clientWidth;
        const y = (-vector.y * 0.5 + 0.5) * container.clientHeight;
        tooltip.style.left = `${x}px`;
        tooltip.style.top = `${y}px`;
    }

    function easeInOutQuart(t) {
        return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t;
    }
})();




