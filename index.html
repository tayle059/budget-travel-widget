  }
  starGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
  const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.3}));
  scene.add(stars);

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.4));
  const directional = new THREE.DirectionalLight(0xffffff, 1);
  directional.position.set(5, 3, 5);
  scene.add(directional);

  // Earth group
  earthGroup = new THREE.Group();
  scene.add(earthGroup);

  const loader = new THREE.TextureLoader();

  // --- Updated textures from Wikimedia ---
  const earthGeo = new THREE.SphereGeometry(1, 64, 64);
  const earthMat = new THREE.MeshPhongMaterial({
    map: loader.load('https://upload.wikimedia.org/wikipedia/commons/2/2c/Blue_Marble_2001-2002.jpg'), // diffuse
    bumpMap: loader.load('https://upload.wikimedia.org/wikipedia/commons/5/50/Earthbump4k.jpg'), // bump
    bumpScale: 0.05,
    specularMap: loader.load('https://upload.wikimedia.org/wikipedia/commons/6/63/Earthspec4k.jpg'), // specular
    specular: new THREE.Color('grey')
  });
  earthMesh = new THREE.Mesh(earthGeo, earthMat);
  earthGroup.add(earthMesh);

  // Clouds
  const cloudGeo = new THREE.SphereGeometry(1.01, 64, 64);
  const cloudMat = new THREE.MeshPhongMaterial({
    map: loader.load('https://threejs.org/examples/textures/planets/earth_clouds_1024.png'),
    transparent: true,
    opacity: 0.3
  });
  cloudMesh = new THREE.Mesh(cloudGeo, cloudMat);
  earthGroup.add(cloudMesh);

  // Atmosphere
  const atmGeo = new THREE.SphereGeometry(1.03, 64, 64);
  const atmMat = new THREE.MeshBasicMaterial({
    color: 0x00aaff,
    transparent: true,
    opacity: 0.1,
    side: THREE.BackSide
  });
  atmosphereMesh = new THREE.Mesh(atmGeo, atmMat);
  earthGroup.add(atmosphereMesh);

  // Markers
  destinations.forEach(dest => {
    const geo = new THREE.SphereGeometry(0.025, 8, 8);
    const mat = new THREE.MeshBasicMaterial({color: 0x888888});
    const marker = new THREE.Mesh(geo, mat);
    const pos = latLonToXYZ(dest.lat, dest.lon, 1.02);
    marker.position.set(pos.x, pos.y, pos.z);
    marker.userData = {destination: dest};
    markers.push(marker);
    earthGroup.add(marker);
  });

  // Glow sprite
  const spriteMat = new THREE.SpriteMaterial({
    color: 0xff4444,
    transparent: true,
    opacity: 0.8,
    blending: THREE.AdditiveBlending
  });
  glowSprite = new THREE.Sprite(spriteMat);
  glowSprite.scale.set(0.15,0.15,0.15);
  glowSprite.visible = false;
  scene.add(glowSprite);

  button.addEventListener('click', startSpin);

  window.addEventListener('resize', () => {
    camera.aspect = container.clientWidth/container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
  });
}

function latLonToXYZ(lat, lon, radius) {
  const phi = THREE.MathUtils.degToRad(90 - lat);
  const theta = THREE.MathUtils.degToRad(lon);
  return {
    x: radius * Math.sin(phi) * Math.sin(theta),
    y: radius * Math.cos(phi),
    z: radius * Math.sin(phi) * Math.cos(theta)
  };
}

function startSpin() {
  if(isSpinning) return;
  tooltip.style.display="none";
  glowSprite.visible=false;

  selectedMarker = markers[Math.floor(Math.random()*markers.length)];

  button.disabled = true;
  button.textContent = "Spinning...";
  isSpinning = true;
  spinStartTime = Date.now();
}

function animate() {
  requestAnimationFrame(animate);

  // Rotate clouds
  if(cloudMesh) cloudMesh.rotation.y += 0.0008;

  if(isSpinning){
    const elapsed = Date.now() - spinStartTime;
    const progress = Math.min(elapsed / SPIN_DURATION, 1);
    const eased = easeInOutQuart(progress);

    const destLon = selectedMarker.userData.destination.lon;
    const destLat = selectedMarker.userData.destination.lat;

    const targetRotY = THREE.MathUtils.degToRad(-destLon);
    const targetRotX = THREE.MathUtils.degToRad(destLat * 0.5);

    const totalRotY = TOTAL_SPINS * Math.PI * 2 + targetRotY;
    const totalRotX = targetRotX;

    earthGroup.rotation.y = totalRotY * eased;
    earthGroup.rotation.x = totalRotX * eased;

    if(progress>=1){
      isSpinning=false;
      button.disabled=false;
      button.textContent="Pick My Travel Destination";
      showTooltip();
    }
  }

  // Update markers
  markers.forEach(m=>{
    m.material.color.set((m===selectedMarker && !isSpinning)?0xff4444:0x888888);
  });

  // Glow
  if(selectedMarker && !isSpinning){
    const worldPos = selectedMarker.position.clone().applyMatrix4(earthGroup.matrixWorld).multiplyScalar(1.08);
    glowSprite.position.copy(worldPos);
    const pulse = 0.15 + 0.05 * Math.sin(Date.now()*0.005);
    glowSprite.scale.set(pulse,pulse,pulse);
    glowSprite.visible=true;
    updateTooltipPosition();
  }

  renderer.render(scene,camera);
}

function showTooltip(){
  tooltip.textContent = "Your next budget trip: "+selectedMarker.userData.destination.name;
  tooltip.style.display="block";
  updateTooltipPosition();
}

function updateTooltipPosition(){
  if(!selectedMarker || tooltip.style.display==="none") return;
  const vector = selectedMarker.position.clone().applyMatrix4(earthGroup.matrixWorld);
  vector.project(camera);
  const x = (vector.x*0.5+0.5)*container.clientWidth;
  const y = (-vector.y*0.5+0.5)*container.clientHeight;
  tooltip.style.left=`${x}px`;
  tooltip.style.top=`${y}px`;
}

function easeInOutQuart(t){
  return t<0.5 ? 8*t*t*t*t : 1-8*(--t)*t*t*t;
}

})();
</script>
</body>
</html>





