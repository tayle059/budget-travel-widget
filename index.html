import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.158/build/three.module.js";

const container = document.getElementById('earthContainer');
const tooltip = document.getElementById('tooltip');
const button = document.getElementById('pickDestination');

let scene, camera, renderer;
let earthGroup, earthMesh, cloudMesh, glowSprite;
let markers = [], selectedMarker = null;
let isSpinning = false, spinStartTime, SPIN_DURATION = 3000;
const TOTAL_SPINS = 3;

const destinations = [
  { name: "Paris, France", lat: 48.8566, lon: 2.3522 },
  { name: "Tokyo, Japan", lat: 35.6895, lon: 139.6917 },
  { name: "New York, USA", lat: 40.7128, lon: -74.0060 },
  { name: "Sydney, Australia", lat: -33.8688, lon: 151.2093 },
  { name: "Cape Town, South Africa", lat: -33.9249, lon: 18.4241 }
];

init();
animate();

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.1, 1000);
  camera.position.set(0, 0, 3);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);

  // Ambient & directional light
  scene.add(new THREE.AmbientLight(0xffffff, 0.4));
  const dirLight = new THREE.DirectionalLight(0xffffff, 1);
  dirLight.position.set(5, 3, 5);
  scene.add(dirLight);

  // Earth group
  earthGroup = new THREE.Group();
  scene.add(earthGroup);

  // Generate pixel Earth texture
  const earthTexture = new THREE.CanvasTexture(generatePixelEarth(64, 32));
  const earthGeo = new THREE.SphereGeometry(1, 64, 64);
  const earthMat = new THREE.MeshPhongMaterial({ map: earthTexture });
  earthMesh = new THREE.Mesh(earthGeo, earthMat);
  earthGroup.add(earthMesh);

  // Clouds (simple transparent sphere)
  const cloudGeo = new THREE.SphereGeometry(1.01, 64, 64);
  const cloudMat = new THREE.MeshPhongMaterial({ transparent: true, opacity: 0.3, color: 0xffffff });
  cloudMesh = new THREE.Mesh(cloudGeo, cloudMat);
  earthGroup.add(cloudMesh);

  // Markers
  destinations.forEach(dest => {
    const markerGeo = new THREE.SphereGeometry(0.025, 8, 8);
    const markerMat = new THREE.MeshBasicMaterial({ color: 0x888888 });
    const marker = new THREE.Mesh(markerGeo, markerMat);
    const pos = latLonToXYZ(dest.lat, dest.lon, 1.02);
    marker.position.set(pos.x, pos.y, pos.z);
    marker.userData = { destination: dest };
    markers.push(marker);
    earthGroup.add(marker);
  });

  // Glow sprite
  const spriteMat = new THREE.SpriteMaterial({ color: 0xff4444, transparent: true, opacity: 0.8 });
  glowSprite = new THREE.Sprite(spriteMat);
  glowSprite.scale.set(0.15, 0.15, 0.15);
  glowSprite.visible = false;
  scene.add(glowSprite);

  button.addEventListener('click', startSpin);
  window.addEventListener('resize', onResize);
}

function generatePixelEarth(width, height) {
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');

  // Simple pixel continents
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const lon = (x / width) * 360 - 180;
      const lat = 90 - (y / height) * 180;
      const color = lat > -60 && lat < 60 && Math.random() > 0.7 ? '#228B22' : '#1E90FF';
      ctx.fillStyle = color;
      ctx.fillRect(x, y, 1, 1);
    }
  }
  return canvas;
}

function latLonToXYZ(lat, lon, radius) {
  const phi = THREE.MathUtils.degToRad(90 - lat);
  const theta = THREE.MathUtils.degToRad(lon + 180);
  return {
    x: -(radius * Math.sin(phi) * Math.cos(theta)),
    y: radius * Math.cos(phi),
    z: radius * Math.sin(phi) * Math.sin(theta)
  };
}

function startSpin() {
  if (isSpinning) return;
  tooltip.style.display = "none";
  glowSprite.visible = false;
  selectedMarker = markers[Math.floor(Math.random() * markers.length)];
  button.disabled = true;
  button.textContent = "Spinning...";
  isSpinning = true;
  spinStartTime = Date.now();
}

function animate() {
  requestAnimationFrame(animate);
  if (cloudMesh) cloudMesh.rotation.y += 0.0005;

  if (isSpinning) {
    const elapsed = Date.now() - spinStartTime;
    const progress = Math.min(elapsed / SPIN_DURATION, 1);
    const eased = easeInOutQuart(progress);

    const destLon = selectedMarker.userData.destination.lon;
    const destLat = selectedMarker.userData.destination.lat;

    const targetRotY = THREE.MathUtils.degToRad(-destLon);
    const targetRotX = THREE.MathUtils.degToRad(destLat);

    const totalRotY = TOTAL_SPINS * Math.PI * 2 + targetRotY;
    earthGroup.rotation.y = totalRotY * eased;
    earthGroup.rotation.x = targetRotX * eased * 0.5;

    if (progress >= 1) {
      isSpinning = false;
      button.disabled = false;
      button.textContent = "Pick My Travel Destination";
      showTooltip();
    }
  }

  markers.forEach(m => {
    m.material.color.set((m === selectedMarker && !isSpinning) ? 0xff4444 : 0x888888);
  });

  if (selectedMarker && !isSpinning) {
    const worldPos = selectedMarker.position.clone().applyMatrix4(earthGroup.matrixWorld);
    glowSprite.position.copy(worldPos);
    glowSprite.visible = true;
    updateTooltipPosition();
  }

  renderer.render(scene, camera);
}

function showTooltip() {
  tooltip.textContent = "Your next budget trip: " + selectedMarker.userData.destination.name;
  tooltip.style.display = "block";
  updateTooltipPosition();
}

function updateTooltipPosition() {
  const vector = selectedMarker.position.clone().applyMatrix4(earthGroup.matrixWorld);
  vector.project(camera);
  const x = (vector.x * 0.5 + 0.5) * container.clientWidth;
  const y = (-vector.y * 0.5 + 0.5) * container.clientHeight;
  tooltip.style.left = `${x}px`;
  tooltip.style.top = `${y}px`;
}

function onResize() {
  camera.aspect = container.clientWidth / container.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container.clientWidth, container.clientHeight);
}

function easeInOutQuart(t) {
  return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t;
}
